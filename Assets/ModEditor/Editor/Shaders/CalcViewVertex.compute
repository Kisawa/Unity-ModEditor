#pragma kernel CalcVertexsWithScreenScope
#pragma kernel SpreadSelectInTirangle
#pragma kernel WriteVertexColorUseSelectData

float4x4 _MV;
float4x4 _P;
float3 _MouseTexcoord;
float _Size;
float _Depth;
int _ClearSpread;
StructuredBuffer<float3> _Vertexs;
RWStructuredBuffer<float> RW_Selects;

[numthreads(1024,1,1)]
void CalcVertexsWithScreenScope(uint3 id : SV_DispatchThreadID)
{
	float3 viewPos = mul(_MV, float4(_Vertexs[id.x], 1.0));
	float depth = -viewPos.z;
	float4 clipPos = mul(_P, float4(viewPos, 1.0));
	float2 screenPos = (clipPos.xy + clipPos.w) * 0.5;
	float2 uv = screenPos / clipPos.w;
	uv.x *= _MouseTexcoord.z;
	_MouseTexcoord.x *= _MouseTexcoord.z;
	float dis = length(uv - _MouseTexcoord.xy);
	float res = (1 - step(_Size, dis)) * (1 - step(_Depth, depth));
	if(_ClearSpread == 1)
		RW_Selects[id.x] = clamp(RW_Selects[id.x], 0, 1);
	if(RW_Selects[id.x] >= 0)
		RW_Selects[id.x] = res;
}

StructuredBuffer<int> _Triangles;
[numthreads(1024,1,1)]
void SpreadSelectInTirangle(uint3 id: SV_DispatchThreadID)
{
	int layer = id.x / 3;
	int vertex_id0 = _Triangles[fmod(id.x, 3) + layer * 3];
	int vertex_id1 = _Triangles[fmod(id.x + 1, 3) + layer * 3];
	int vertex_id2 = _Triangles[fmod(id.x + 2, 3) + layer * 3];
	float select0 = RW_Selects[vertex_id0];
	float select1 = RW_Selects[vertex_id1];
	float select2 = RW_Selects[vertex_id2];
	float res = min(select0, select1);
	res = min(res, select2) - 1;
	res -= (1 - any(res));
	res = any(float3(select0, select1, select2)) * res;
	RW_Selects[vertex_id0] += (1 - any(select0)) * res;
}

float4 _Color;
RWStructuredBuffer<float4> RW_Colors;
[numthreads(1024,1,1)]
void WriteVertexColorUseSelectData(uint3 id: SV_DispatchThreadID)
{
	RW_Colors[id.x] = lerp(RW_Colors[id.x], _Color, any(RW_Selects[id.x]));
}