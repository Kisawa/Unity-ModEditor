#pragma kernel CalcVertexsWithScreenScope
#pragma kernel SpreadSelectInTirangle
#pragma kernel RespreadSelectInTirangle
#pragma kernel LockZone
#pragma kernel AddZone
#pragma kernel SubZone
#pragma kernel WriteVertexColorUseSelectData

float4x4 _MV;
float4x4 _P;
float3 _MouseTexcoord;
float _Size;
float _Depth;
bool _ClearSpread;
int _OnlyZone;
StructuredBuffer<float3> _Vertexs;
RWStructuredBuffer<float> RW_Selects;
RWStructuredBuffer<float> RW_Depths;
RWStructuredBuffer<int> RW_Zone;

[numthreads(1024,1,1)]
void CalcVertexsWithScreenScope(uint3 id : SV_DispatchThreadID)
{
	float3 viewPos = mul(_MV, float4(_Vertexs[id.x], 1.0)).xyz;
	float depth = -viewPos.z;
	RW_Depths[id.x] = depth;
	float4 clipPos = mul(_P, float4(viewPos, 1.0));
	float2 screenPos = (clipPos.xy + clipPos.w) * 0.5;
	float2 uv = screenPos / clipPos.w;
	uv.x *= _MouseTexcoord.z;
	float2 mouseTexcoord = _MouseTexcoord.xy;
	mouseTexcoord.x *= _MouseTexcoord.z;
	float dis = distance(uv, mouseTexcoord);
	float res = (1 - step(_Size, dis)) * (1 - step(_Depth, depth));
	int zone = max(RW_Zone[id.x], _OnlyZone);
	res *= zone;
	if(_ClearSpread)
		RW_Selects[id.x] = -res;
	else
	{
		float pre = RW_Selects[id.x];
		pre *= zone;
		//if(pre == 0) RW_Selects[id.x] = -res;
		RW_Selects[id.x] = pre - (1 - any(pre)) * res;
	}
}

StructuredBuffer<int> _Triangles;
[numthreads(1024,1,1)]
void SpreadSelectInTirangle(uint3 id: SV_DispatchThreadID)
{
	int layer = id.x / 3;
	int vertex_id0 = _Triangles[fmod(id.x, 3) + layer * 3];
	int vertex_id1 = _Triangles[fmod(id.x + 1, 3) + layer * 3];
	int vertex_id2 = _Triangles[fmod(id.x + 2, 3) + layer * 3];
	float select0 = RW_Selects[vertex_id0];
	float select1 = RW_Selects[vertex_id1];
	float select2 = RW_Selects[vertex_id2];

	float res = max(select0, select1);
	res = max(res, select2);
	res = max(res, 0) + 1;
	int write = any(float3(select0, select1, select2));
	if(write == 1)
	{
		RW_Selects[vertex_id0] = select0 + (1 - any(select0)) * res;
		RW_Selects[vertex_id1] = select1 + (1 - any(select1)) * res;
		RW_Selects[vertex_id2] = select2 + (1 - any(select2)) * res;
	}
}

int _SpreadLevel;
[numthreads(1024,1,1)]
void RespreadSelectInTirangle(uint3 id: SV_DispatchThreadID)
{
	int layer = id.x / 3;
	int vertex_id0 = _Triangles[fmod(id.x, 3) + layer * 3];
	int vertex_id1 = _Triangles[fmod(id.x + 1, 3) + layer * 3];
	int vertex_id2 = _Triangles[fmod(id.x + 2, 3) + layer * 3];
	float select0 = RW_Selects[vertex_id0];
	float select1 = RW_Selects[vertex_id1];
	float select2 = RW_Selects[vertex_id2];
	RW_Selects[vertex_id0] = select0 * step(0, _SpreadLevel - select0);
	RW_Selects[vertex_id1] = select1 * step(0, _SpreadLevel - select1);
	RW_Selects[vertex_id2] = select2 * step(0, _SpreadLevel - select2);
}

[numthreads(1024,1,1)]
void LockZone(uint3 id: SV_DispatchThreadID)
{
	int res = any(RW_Selects[id.x]);
	RW_Zone[id.x] = res;
}

[numthreads(1024,1,1)]
void AddZone(uint3 id: SV_DispatchThreadID)
{
	int res = any(RW_Selects[id.x]);
	res = max(RW_Zone[id.x], res);
	RW_Zone[id.x] = res;
}

[numthreads(1024,1,1)]
void SubZone(uint3 id: SV_DispatchThreadID)
{
	int res = 1 - any(RW_Selects[id.x]);
	res = min(RW_Zone[id.x], res);
	RW_Zone[id.x] = res;
}

float4 _Color;
RWStructuredBuffer<float4> RW_Colors;
[numthreads(1024,1,1)]
void WriteVertexColorUseSelectData(uint3 id: SV_DispatchThreadID)
{
	RW_Colors[id.x] = lerp(RW_Colors[id.x], _Color, any(RW_Selects[id.x]));
}