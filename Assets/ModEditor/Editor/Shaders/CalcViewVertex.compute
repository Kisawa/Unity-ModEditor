#pragma kernel SelectWithScreenScope
#pragma kernel SpreadSelect
#pragma kernel RespreadSelect
#pragma kernel LockZone
#pragma kernel AddZone
#pragma kernel SubZone
#pragma kernel CalcWithSize
#pragma kernel CalcWithSpread
#pragma kernel Result

float4x4 _MV;
float4x4 _P;
float3 _MouseTexcoord;
float _Size;
float _Depth;
bool _ClearSpread;
int _OnlyZone;
int _ZoneInSelect;
StructuredBuffer<float3> _Vertexs;
RWStructuredBuffer<float> RW_Selects;
RWStructuredBuffer<float> RW_Depths;
RWStructuredBuffer<float> RW_Sizes;
RWStructuredBuffer<int> RW_Zone;

[numthreads(1024,1,1)]
void SelectWithScreenScope(uint3 id : SV_DispatchThreadID)
{
	float3 viewPos = mul(_MV, float4(_Vertexs[id.x], 1.0)).xyz;
	float depth = -viewPos.z;
	RW_Depths[id.x] = depth;
	float4 clipPos = mul(_P, float4(viewPos, 1.0));
	float2 screenPos = (clipPos.xy + clipPos.w) * 0.5;
	float2 uv = screenPos / clipPos.w;
	uv.x *= _MouseTexcoord.z;
	float2 mouseTexcoord = _MouseTexcoord.xy;
	mouseTexcoord.x *= _MouseTexcoord.z;
	float dis = distance(uv, mouseTexcoord);
	RW_Sizes[id.x] = dis;
	float res = (1 - step(_Size, dis)) * (1 - step(_Depth, depth));
	int isZone = RW_Zone[id.x];
	int zone = max(isZone, _OnlyZone);
	res *= zone;
	res = lerp(res, 1, isZone * _ZoneInSelect);
	if(_ClearSpread)
		RW_Selects[id.x] = -res;
	else if(RW_Selects[id.x] * zone <= 0)
		RW_Selects[id.x] = -res;
}

StructuredBuffer<int> _Triangles;
[numthreads(1024,1,1)]
void SpreadSelect(uint3 id: SV_DispatchThreadID)
{
	int layer = id.x / 3;
	int vertex_id0 = _Triangles[fmod(id.x, 3) + layer * 3];
	int vertex_id1 = _Triangles[fmod(id.x + 1, 3) + layer * 3];
	int vertex_id2 = _Triangles[fmod(id.x + 2, 3) + layer * 3];
	float select0 = RW_Selects[vertex_id0];
	float select1 = RW_Selects[vertex_id1];
	float select2 = RW_Selects[vertex_id2];

	float res = max(select0, select1);
	res = max(res, select2);
	res = max(res, 0) + 1;
	int write = any(float3(select0, select1, select2));
	if(write == 1)
	{
		RW_Selects[vertex_id0] = select0 + (1 - any(select0)) * res;
		RW_Selects[vertex_id1] = select1 + (1 - any(select1)) * res;
		RW_Selects[vertex_id2] = select2 + (1 - any(select2)) * res;
	}
}

int _SpreadLevel;
[numthreads(1024,1,1)]
void RespreadSelect(uint3 id: SV_DispatchThreadID)
{
	int layer = id.x / 3;
	int vertex_id0 = _Triangles[fmod(id.x, 3) + layer * 3];
	int vertex_id1 = _Triangles[fmod(id.x + 1, 3) + layer * 3];
	int vertex_id2 = _Triangles[fmod(id.x + 2, 3) + layer * 3];
	float select0 = RW_Selects[vertex_id0];
	float select1 = RW_Selects[vertex_id1];
	float select2 = RW_Selects[vertex_id2];
	RW_Selects[vertex_id0] = select0 * step(0, _SpreadLevel - select0);
	RW_Selects[vertex_id1] = select1 * step(0, _SpreadLevel - select1);
	RW_Selects[vertex_id2] = select2 * step(0, _SpreadLevel - select2);
}

[numthreads(1024,1,1)]
void LockZone(uint3 id: SV_DispatchThreadID)
{
	int res = any(RW_Selects[id.x]);
	RW_Zone[id.x] = res;
}

[numthreads(1024,1,1)]
void AddZone(uint3 id: SV_DispatchThreadID)
{
	int res = any(RW_Selects[id.x]);
	res = max(RW_Zone[id.x], res);
	RW_Zone[id.x] = res;
}

[numthreads(1024,1,1)]
void SubZone(uint3 id: SV_DispatchThreadID)
{
	int res = 1 - any(RW_Selects[id.x]);
	res = min(RW_Zone[id.x], res);
	RW_Zone[id.x] = res;
}

float remap(float num, float inMin, float inMax, float outMin, float outMax)
{
	return outMin + (num - inMin) * (outMax - outMin) / (inMax - inMin);
}

float4 _ColorFrom;
float4 _ColorTo;
float _FromStep;
float _ToStep;
RWStructuredBuffer<float4> RW_Colors;
[numthreads(1024,1,1)]
void CalcWithSize(uint3 id: SV_DispatchThreadID)
{
	int select = any(RW_Selects[id.x]);
	float4 col = lerp(0, _ColorFrom, select);
	float res = RW_Sizes[id.x] / _Size * select;
	RW_Colors[id.x] = lerp(col, _ColorTo, clamp(remap(res, _FromStep, _ToStep, 0, 1), 0, 1));
}

[numthreads(1024,1,1)]
void CalcWithSpread(uint3 id: SV_DispatchThreadID)
{
	float spread = RW_Selects[id.x];
	int select = any(spread);
	spread -= clamp(sign(spread), -1, 0);
	float4 col = lerp(0, _ColorFrom, select);
	float res = spread / _SpreadLevel * select;
	RW_Colors[id.x] = lerp(col, _ColorTo, clamp(remap(res, _FromStep, _ToStep, 0, 1), 0, 1));
}

int _Type;
RWStructuredBuffer<float4> RW_Result;
[numthreads(1024,1,1)]
void Result(uint3 id: SV_DispatchThreadID)
{
	int select = any(RW_Selects[id.x]);
	float4 pre = RW_Result[id.x];
	switch(_Type)
	{
		case 0:
		RW_Result[id.x] = lerp(pre, RW_Colors[id.x], select);
		break;
		case 1:
		RW_Result[id.x] = pre + RW_Colors[id.x] * select;
		break;
		case 2:
		RW_Result[id.x] = pre - RW_Colors[id.x] * select;
		break;
		case 3:
		if(select == 1)
			RW_Result[id.x] = pre * RW_Colors[id.x];
		break;
	}
}